rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() { return request.auth != null; }
    function isOwner(uid) { return isSignedIn() && request.auth.uid == uid; }
    function isValidUsername(u) { return u.matches('^[a-z0-9_]{3,20}$'); }
    function karmaValue(data) {
      return (data.karma is int) ? data.karma : 0;
    }
    function isValidKarmaDelta(delta) {
      return delta in [-2, -1, 1, 2];
    }
    function isValidKarmaUpdate() {
      return isSignedIn()
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['karma'])
        && request.resource.data.karma is int
        && isValidKarmaDelta(karmaValue(request.resource.data) - karmaValue(resource.data));
    }

    function voteValue(voteMap, uid) {
      // Handle case where voteMap doesn't exist (returns false, meaning no vote)
      return (voteMap is map) && voteMap[uid] == true;
    }
    function voteScoreValue(data) {
      // Handle both int and float (Firestore numbers can be either)
      // Convert to int for consistent comparison
      if (!('voteScore' in data)) return 0;
      if (data.voteScore is int) return data.voteScore;
      if (data.voteScore is float) {
        // Convert float to int (Firestore rules don't have int() function, so we compare directly)
        // For vote scores, floats should be whole numbers, so we can compare as-is
        return data.voteScore;
      }
      return 0;
    }
    function voteDelta(prevUp, prevDown, newUp, newDown) {
      return prevUp
        ? (newUp ? 0 : (newDown ? -2 : -1))
        : (prevDown ? (newDown ? 0 : (newUp ? 2 : 1))
            : (newUp ? 1 : (newDown ? -1 : 0)));
    }
    function isValidVoteUpdate() {
      // Check basic requirements: signed in, maps are valid, only vote fields updated
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      
      // Safely get vote values, handling missing maps
      let prevUp = ('upvotes' in resource.data && resource.data.upvotes is map) 
                   ? voteValue(resource.data.upvotes, request.auth.uid) 
                   : false;
      let prevDown = ('downvotes' in resource.data && resource.data.downvotes is map)
                     ? voteValue(resource.data.downvotes, request.auth.uid)
                     : false;
      let newUp = ('upvotes' in request.resource.data && request.resource.data.upvotes is map)
                  ? voteValue(request.resource.data.upvotes, request.auth.uid)
                  : false;
      let newDown = ('downvotes' in request.resource.data && request.resource.data.downvotes is map)
                    ? voteValue(request.resource.data.downvotes, request.auth.uid)
                    : false;
      let expectedDelta = voteDelta(prevUp, prevDown, newUp, newDown);
      let actualDelta = voteScoreValue(request.resource.data) - voteScoreValue(resource.data);
      
      // Check that required vote fields are affected
      // upvotes and voteScore must always be in affectedKeys
      // downvotes might not be in affectedKeys if it was {} and remains {} (Firestore doesn't detect identical map changes)
      let hasUpvotes = affectedKeys.hasAny(['upvotes']);
      let hasVoteScore = affectedKeys.hasAny(['voteScore']);
      let hasDownvotes = affectedKeys.hasAny(['downvotes']);
      // Only require upvotes and voteScore - downvotes is optional if unchanged
      let hasRequiredFields = hasUpvotes && hasVoteScore;
      
      // No forbidden fields can be updated (this ensures only vote fields + updatedAt can be changed)
      // updatedAt is allowed (not in forbidden list) and can be serverTimestamp()
      let noForbiddenFields = !affectedKeys.hasAny(['userId', 'username', 'content', 'images', 'videos', 'deleted', 'editedAt', 'commentsCount', 'createdAt']);
      
      // Allow voteScore to be int or float
      let oldVoteScoreValid = !('voteScore' in resource.data) 
        || resource.data.voteScore is int 
        || resource.data.voteScore is float;
      let newVoteScoreValid = request.resource.data.voteScore is int 
        || request.resource.data.voteScore is float;
      
      // Delta check
      let deltaCheck = ('voteScore' in resource.data) 
        ? (actualDelta == expectedDelta)
        : (request.resource.data.voteScore == expectedDelta);
      
      return isSignedIn()
        && hasRequiredFields
        && noForbiddenFields
        && request.resource.data.upvotes is map
        && request.resource.data.downvotes is map
        && (!('upvotes' in resource.data) || resource.data.upvotes is map)
        && (!('downvotes' in resource.data) || resource.data.downvotes is map)
        && (prevUp != newUp || prevDown != newDown)
        && !(newUp && newDown)
        && newVoteScoreValid
        && oldVoteScoreValid
        && deltaCheck;
    }    // Public rules version doc
    match /meta/{docId} {
      allow read: if docId == "rules";
      allow write: if false;
    }

    // Username registry
    match /usernames/{username} {
      allow get: if true;
      allow list: if false;

      // createdAt is required and must be a timestamp (set via Timestamp.now())
      allow create: if isSignedIn()
        && isValidUsername(username)
        && request.resource.data.keys().hasOnly(['uid','createdAt'])
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.uid is string
        && request.resource.data.createdAt is timestamp
        && !exists(/databases/$(database)/documents/usernames/$(username));

      // Allow rollback/cleanup for own claim
      allow delete: if isSignedIn() && resource.data.uid == request.auth.uid;

      allow update: if false;
    }

    // Private user profiles
    match /users/{uid} {
      // Allow users to read their own profile
      // Allow authenticated users to read other profiles (for role checks in chat, leaderboard)
      // Allow public read for homepage/leaderboard (public data)
      allow get: if true;
      // Allow public queries for leaderboard/homepage (public data)
      allow list: if true;

      // createdAt is required and must be a timestamp (set via Timestamp.now())
      allow create: if isOwner(uid)
        && request.resource.data.keys().hasOnly(['username','email','avatarCount','createdAt'])
        && request.resource.data.username is string
        && isValidUsername(request.resource.data.username)
        && request.resource.data.email is string
        && request.resource.data.avatarCount is int
        && request.resource.data.avatarCount >= 0
        && request.resource.data.createdAt is timestamp;

      // Allow updates to profile fields (bio, country, bannerImage, bannerBackground, updatedAt, points, rank, totalQuestsCompleted)
      // Points, rank, and totalQuestsCompleted can be updated via transactions (for quest completion)
      // Admins/moderators can update role and mutedUntil fields for moderation
      allow update: if (
        // User updating their own profile (with restrictions)
        (isOwner(uid)
          && (!('username' in request.resource.data.diff(resource.data).affectedKeys())
              || request.resource.data.username == resource.data.username)
          && (!('email' in request.resource.data.diff(resource.data).affectedKeys())
              || request.resource.data.email == resource.data.email)
          && (!('avatarCount' in request.resource.data.diff(resource.data).affectedKeys())
              || request.resource.data.avatarCount == resource.data.avatarCount)
          && (!('createdAt' in request.resource.data.diff(resource.data).affectedKeys())
              || request.resource.data.createdAt == resource.data.createdAt)
          && (!('role' in request.resource.data.diff(resource.data).affectedKeys()))
          && (!('mutedUntil' in request.resource.data.diff(resource.data).affectedKeys()))
          && (!('karma' in request.resource.data.diff(resource.data).affectedKeys())))
        ||
        // Any authenticated user updating karma (when voting on posts)
        (isValidKarmaUpdate())
        ||
        // Admin/moderator updating role or mutedUntil (for moderation)
        // updateDoc only sends changed fields in request.resource.data
        (isAdminOrMod(request.auth.uid)
          && (request.resource.data.keys().hasOnly(['role'])
              || request.resource.data.keys().hasOnly(['mutedUntil'])
              || request.resource.data.keys().hasOnly(['role', 'mutedUntil']))
          && !('username' in request.resource.data)
          && !('email' in request.resource.data)
          && !('avatarCount' in request.resource.data)
          && !('createdAt' in request.resource.data)
          && !('karma' in request.resource.data))
      );

      allow delete: if false;
    }

    // Helper function to check if user is admin/moderator
    function isAdminOrMod(uid) {
      return isSignedIn() && 
        exists(/databases/$(database)/documents/users/$(uid)) &&
        get(/databases/$(database)/documents/users/$(uid)).data.role in ['admin', 'moderator'];
    }

    // Chat messages
    match /messages/{messageId} {
      // Allow public read for homepage activity feed (public data)
      // Authenticated users can read all messages
      allow read: if true;
      
      // Only authenticated users can create messages
      // Note: timestamp can be serverTimestamp() sentinel, so we don't validate it strictly
      // Support both channel (global) and communityId (community) messages
      allow create: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.username is string
        && request.resource.data.text is string
        && request.resource.data.channel is string
        && request.resource.data.avatarCount is int
        && request.resource.data.deleted == false
        && (
          // Global channel message (no communityId)
          (!('communityId' in request.resource.data))
          ||
          // Community message - user must be a member
          ('communityId' in request.resource.data 
            && request.resource.data.communityId is string
            && exists(/databases/$(database)/documents/communities/$(request.resource.data.communityId)/members/$(request.auth.uid)))
        );
      
      // Users can update their own messages (for editing, reactions)
      // Admins can update any message (for moderation)
      // Community admins/moderators can update messages in their communities
      allow update: if isSignedIn() && (
        (resource.data.userId == request.auth.uid
          && (!('userId' in request.resource.data) || request.resource.data.userId == resource.data.userId)
          && (!('username' in request.resource.data) || request.resource.data.username == resource.data.username))
        ||
        isAdminOrMod(request.auth.uid)
        ||
        // Community admin/moderator can update messages in their community
        ('communityId' in resource.data 
          && resource.data.communityId is string
          && exists(/databases/$(database)/documents/communities/$(resource.data.communityId)/members/$(request.auth.uid))
          && get(/databases/$(database)/documents/communities/$(resource.data.communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin', 'moderator']
          && (!('userId' in request.resource.data) || request.resource.data.userId == resource.data.userId)
          && (!('username' in request.resource.data) || request.resource.data.username == resource.data.username))
      );
      
      // Users can delete their own messages (soft delete)
      // Admins can delete any message
      allow delete: if false; // Use soft delete (update deleted flag) instead
    }

    // Typing indicators
    match /typing/{userId} {
      // Anyone authenticated can read typing indicators
      allow read: if isSignedIn();
      
      // Users can only write their own typing indicator
      // Note: timestamp can be serverTimestamp() sentinel
      allow create, update: if isSignedIn() && userId == request.auth.uid
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.channel is string;
      
      // Users can delete their own typing indicator
      allow delete: if isSignedIn() && userId == request.auth.uid;
    }

    // User presence (online/offline status)
    match /presence/{userId} {
      // Allow public read for homepage online count (public data)
      allow read: if true;
      
      // Users can only write their own presence
      // Note: lastSeen can be serverTimestamp() sentinel
      allow create, update: if isSignedIn() && userId == request.auth.uid
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.online is bool;
      
      // Users can delete their own presence
      allow delete: if isSignedIn() && userId == request.auth.uid;
    }

    // Channels (for future multi-channel support)
    match /channels/{channelId} {
      // Anyone authenticated can read channels
      allow read: if isSignedIn();
      
      // Only admins can create/update channels
      allow create, update: if isAdminOrMod(request.auth.uid);
      
      allow delete: if false;
    }

    // Quests collection (read-only for authenticated users)
    match /quests/{questId} {
      // Anyone authenticated can read quests
      allow read: if isSignedIn();
      
      // Only admins can create/update quests
      allow create, update: if isAdminOrMod(request.auth.uid);
      
      allow delete: if false;
    }

    // User quests progress
    match /userQuests/{userQuestId} {
      // Users can read their own quest progress (both get and list/query)
      // For queries, Firestore checks this rule against each document
      // Allow get even if document doesn't exist (needed for transactions)
      // Also allow reading any document in userQuests if user is signed in (for transactions)
      allow get: if isSignedIn();
      
      allow list: if isSignedIn();
      
      // Users can create their own quest progress
      // Document ID format: {uid}_{questId}
      // Only allow if userId in data matches authenticated user
      allow create: if isSignedIn()
        && request.resource.data.userId == request.auth.uid;
      
      // Users can update their own quest progress
      // Allow updates if document belongs to user
      // Don't allow changing userId or questId
      // transaction.update() only includes fields being updated
      allow update: if isSignedIn()
        && resource.data.userId == request.auth.uid
        && (!('userId' in request.resource.data) || request.resource.data.userId == resource.data.userId)
        && (!('questId' in request.resource.data) || request.resource.data.questId == resource.data.questId);
      
      allow delete: if false; // Don't allow deletion, use reset instead
    }

    // Followers collection
    match /followers/{userId}/followers/{followerId} {
      // Anyone authenticated can read individual follower documents
      allow get: if isSignedIn();
      // Anyone authenticated can list followers (for queries)
      allow list: if isSignedIn();
      // Only the follower themselves can create/delete their follow relationship
      allow create: if isSignedIn() 
        && followerId == request.auth.uid
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasOnly(['userId', 'followedAt']);
      allow delete: if isSignedIn() && followerId == request.auth.uid;
      allow update: if false;
    }

    // Following collection
    match /following/{userId}/following/{followingId} {
      // Anyone authenticated can read individual following documents
      allow get: if isSignedIn();
      // Anyone authenticated can list following (for queries)
      allow list: if isSignedIn();
      // Only the user themselves can create/delete their following relationship
      allow create: if isSignedIn() 
        && userId == request.auth.uid
        && request.resource.data.userId == followingId
        && request.resource.data.keys().hasOnly(['userId', 'followedAt']);
      allow delete: if isSignedIn() && userId == request.auth.uid;
      allow update: if false;
    }

    // Posts collection
    match /posts/{postId} {
      // Allow public read (for homepage trending, feed page)
      // Query filters out deleted posts with where('deleted', '==', false)
      allow read: if true;
      
      // Only authenticated users can create posts
      allow create: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.username is string
        && request.resource.data.content is string
        && request.resource.data.images is list
        && request.resource.data.upvotes is map
        && request.resource.data.downvotes is map
        && request.resource.data.voteScore == 0
        && request.resource.data.commentsCount == 0
        && request.resource.data.deleted == false;
      
      // Post authors can update their own posts (for deleting, editing)
      // Authenticated users can update votes (upvotes/downvotes/voteScore) and commentsCount
      allow update: if isSignedIn() && (
        // Post author updating their own post
        (resource.data.userId == request.auth.uid
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['content', 'images', 'videos', 'deleted', 'editedAt', 'updatedAt'])
          && (!('userId' in request.resource.data) || request.resource.data.userId == resource.data.userId)
          && (!('username' in request.resource.data) || request.resource.data.username == resource.data.username))
        ||
        // Any authenticated user updating votes (for upvoting/downvoting)
        // isValidVoteUpdate() allows updatedAt to be updated along with vote fields
        (isValidVoteUpdate())
        ||
        // Any authenticated user updating commentsCount
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['commentsCount', 'updatedAt']))
      );
      
      allow delete: if false; // Use soft delete (update deleted flag) instead
      
      // Comments subcollection
      match /comments/{commentId} {
        // Allow public read
        // Query filters out deleted comments with where('deleted', '==', false)
        allow read: if true;
        
        // Only authenticated users can create comments
        allow create: if isSignedIn()
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.username is string
          && request.resource.data.content is string
          && request.resource.data.deleted == false;
        
      // Comment authors can update their own comments (for deleting)
      allow update: if isSignedIn()
        && resource.data.userId == request.auth.uid
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['content', 'deleted', 'editedAt', 'updatedAt'])
        && (!('userId' in request.resource.data) || request.resource.data.userId == resource.data.userId)
        && (!('username' in request.resource.data) || request.resource.data.username == resource.data.username);
        
        allow delete: if false; // Use soft delete (update deleted flag) instead
      }
    }

    // Game leaderboard collection
    match /gameLeaderboard/{userId} {
      // Allow public read (anyone can view leaderboard) - both get and list
      allow get: if true;
      allow list: if true;
      
      // Users can create their own leaderboard entry
      allow create: if isSignedIn()
        && userId == request.auth.uid
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.score is int
        && request.resource.data.username is string;
      
      // Users can update their own leaderboard entry (only if new score is higher)
      allow update: if isSignedIn()
        && userId == request.auth.uid
        && resource.data.userId == request.auth.uid
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.score is int
        && request.resource.data.score >= resource.data.score;
      
      allow delete: if false;
    }

    // Reports collection
    match /reports/{reportId} {
      // Users can create reports (composite ID prevents duplicates: {postId}_{userId})
      allow create: if isSignedIn()
        && request.resource.data.reportedBy == request.auth.uid
        && request.resource.data.postId is string
        && request.resource.data.reportedUser is string
        && request.resource.data.reason is string
        && request.resource.data.reason in ['spam', 'harassment', 'inappropriate', 'misinformation', 'other']
        && request.resource.data.reviewed == false;
      
      // Users cannot read reports via get (permission check handled in code with error catching)
      // Only admins/moderators can read reports for moderation
      // Note: checkIfAlreadyReported will get permission error, which is handled gracefully
      allow get: if isAdminOrMod(request.auth.uid);
      
      // Only admins/moderators can list/query reports
      allow list: if isAdminOrMod(request.auth.uid);
      
      // Only admins/moderators can update review status
      allow update: if isAdminOrMod(request.auth.uid)
        && (!('postId' in request.resource.data) || request.resource.data.postId == resource.data.postId)
        && (!('reportedBy' in request.resource.data) || request.resource.data.reportedBy == resource.data.reportedBy)
        && (!('reportedUser' in request.resource.data) || request.resource.data.reportedUser == resource.data.reportedUser)
        && (!('reason' in request.resource.data) || request.resource.data.reason == resource.data.reason)
        && (!('createdAt' in request.resource.data) || request.resource.data.createdAt == resource.data.createdAt);
      
      // No deletion (use soft delete via reviewed flag)
      allow delete: if false;
    }

    // Communities collection
    match /communities/{communityId} {
      // Anyone can read public communities
      // Users can read private communities they are members of
      // Default community is always readable
      allow get: if resource.data.isPublic == true
        || resource.data.isDefault == true
        || (isSignedIn() && exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)));
      
      // For list queries, allow authenticated users to list communities they can access
      // Each document in the result is checked individually
      // Allow listing if community is public, default, user is the creator, or user is a member
      allow list: if isSignedIn() && (
        (resource.data.isPublic == true)
        || (resource.data.isDefault == true)
        || (resource.data.creatorId == request.auth.uid)
        || (exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)))
      );      
      // Only authenticated users can create communities
      allow create: if isSignedIn()
        && request.resource.data.creatorId == request.auth.uid
        && request.resource.data.name is string
        && request.resource.data.isPublic is bool
        && request.resource.data.inviteCode is string
        && request.resource.data.memberCount == 1
        && request.resource.data.createdAt is timestamp;
      
      // Only community owner/admins can update community settings
      // For default community, allow updating memberCount (for auto-join) - simplified check
      allow update: if isSignedIn() && (
        resource.data.creatorId == request.auth.uid ||
        (exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid))
          && get(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin']) ||
        (communityId == 'default' && 
         'memberCount' in request.resource.data &&
         request.resource.data.memberCount is int)
      );
      
      // Only owner can delete community
      allow delete: if isSignedIn() && resource.data.creatorId == request.auth.uid;
      
      // Community members subcollection
      match /members/{memberId} {
        // Users can read their own member document (to check membership)
        // Users can also read members of communities they belong to
        allow get: if isSignedIn() && (
          memberId == request.auth.uid ||
          exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid))
        );
        allow list: if isSignedIn() && (
          exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid))
        );
        
        // Users can add themselves when joining
        // Owner/admins can add other users
        // For default community, allow any authenticated user to add themselves
        allow create: if isSignedIn() && (
          (memberId == request.auth.uid && request.resource.data.userId == request.auth.uid) ||
          (communityId == 'default' && memberId == request.auth.uid && request.resource.data.userId == request.auth.uid) ||
          (exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid))
            && get(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin'])
        );
        
        // Owner/admins can update member roles
        // Users can update their own member document (for lastSeen, etc.)
        allow update: if isSignedIn() && (
          (memberId == request.auth.uid) ||
          (exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid))
            && get(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin'])
        );
        
        // Users can remove themselves
        // Owner/admins can remove other members
        allow delete: if isSignedIn() && (
          memberId == request.auth.uid ||
          (exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid))
            && get(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin'])
        );
      }
      
      // Community channels subcollection
      match /channels/{channelId} {
        // Members can read channels
        // Default community (ID: 'default') channels are readable by all authenticated users
        allow read: if isSignedIn() && (
          exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)) ||
          communityId == 'default'
        );
        
        // Only owner/admins can create channels
        allow create: if isSignedIn() && (
          resource.data.creatorId == request.auth.uid ||
          (exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid))
            && get(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin'])
        );
        
        // Only owner/admins can update channels
        allow update: if isSignedIn() && (
          resource.data.creatorId == request.auth.uid ||
          (exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid))
            && get(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin'])
        );
        
        // Only owner/admins can delete channels
        allow delete: if isSignedIn() && (
          resource.data.creatorId == request.auth.uid ||
          (exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid))
            && get(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin'])
        );
      }
      
      // Community messages subcollection
      match /messages/{messageId} {
        // Members can read messages
        // Default community (ID: 'default') messages are readable by all authenticated users
        allow read: if isSignedIn() && (
          exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)) ||
          communityId == 'default'
        );
        
        // Members can create messages
        // For default community, allow if user is authenticated (will auto-join)
        allow create: if isSignedIn() && (
          (exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)) ||
           communityId == 'default') &&
          request.resource.data.userId == request.auth.uid &&
          request.resource.data.username is string &&
          request.resource.data.text is string &&
          request.resource.data.channelId is string &&
          request.resource.data.deleted == false
        );
        
        // Message author can update their own messages (with 5-minute edit limit)
        // Community admins/moderators can update messages
        allow update: if isSignedIn() && (
        (resource.data.userId == request.auth.uid &&
         resource.data.timestamp.seconds > (request.time.seconds - 300) &&
         (!('userId' in request.resource.data) || request.resource.data.userId == resource.data.userId) &&
         (!('username' in request.resource.data) || request.resource.data.username == resource.data.username))
        ||
        (exists(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid))
          && get(/databases/$(database)/documents/communities/$(communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin', 'moderator']
          && (!('userId' in request.resource.data) || request.resource.data.userId == resource.data.userId)
          && (!('username' in request.resource.data) || request.resource.data.username == resource.data.username))
      );
        
        // Message author can delete (soft delete via update)
        // Community admins/moderators can delete
        // Use soft delete (update deleted flag) instead of actual delete
        allow delete: if false; // Use soft delete via update instead
      }
    }
    
    // Community invites collection (optional, for tracking)
    match /communityInvites/{inviteId} {
      // Anyone authenticated can read invites (to validate codes)
      allow get: if isSignedIn();
      allow list: if false; // No list queries needed
      
      // Community owner/admins can create invites
      allow create: if isSignedIn()
        && request.resource.data.communityId is string
        && request.resource.data.code is string
        && request.resource.data.createdBy == request.auth.uid
        && exists(/databases/$(database)/documents/communities/$(request.resource.data.communityId)/members/$(request.auth.uid))
        && get(/databases/$(database)/documents/communities/$(request.resource.data.communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin'];
      
      // Owner/admins can update/delete invites
      allow update, delete: if isSignedIn()
        && resource.data.communityId is string
        && exists(/databases/$(database)/documents/communities/$(resource.data.communityId)/members/$(request.auth.uid))
        && get(/databases/$(database)/documents/communities/$(resource.data.communityId)/members/$(request.auth.uid)).data.role in ['owner', 'admin'];
    }

    // Default deny
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
